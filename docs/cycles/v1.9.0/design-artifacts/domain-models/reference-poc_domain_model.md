# ドメインモデル設計: 参照方式PoC

## 1. 概要

プロンプト内で外部ファイルを参照する方式を検証し、AI-DLCのモジュール化を実現するための前提条件を確立する。

## 2. ドメインの境界

### 対象範囲

- **`instruction-based`（指示形式）** の検証のみ
- Claude Code での動作確認
- 参照深度（ネスト参照）の制約確認

### 対象外

- **`@notation`（@ 記法）の検証** - Claude Code 限定機能のため、本 PoC では参考情報として記載のみ
- 実際のプロンプトの修正（Unit 002, 003 で実施）
- 参照漏れチェック機構（Unit 004 で実施）
- KiroCLI での必須検証（ユーザー確認による代替とする）

## 3. 主要エンティティ

### 3.1 参照方式（ReferenceMethod）

| 属性 | 説明 |
|------|------|
| 方式ID | 一意の識別子 |
| 方式名 | `@notation`, `instruction-based` |
| 記法例 | `@path/to/file.md`, `「path/to/file.md を読み込んでください」` |
| 処理主体 | クライアント / AI |
| 対応環境 | Claude Code / KiroCLI / その他 |

### 3.2 検証ケース（VerificationCase）

| 属性 | 説明 |
|------|------|
| ケースID | 一意の識別子 |
| 参照方式 | 使用する参照方式 |
| 参照深度 | 1（単一）/ 2（2段階ネスト）/ N |
| 環境 | Claude Code / KiroCLI |
| 期待結果 | 成功 / 失敗 |

### 3.3 検証結果（VerificationResult）

| 属性 | 説明 |
|------|------|
| ケースID | 対象の検証ケース |
| 実行日時 | 検証実行日時 |
| 結果 | 成功 / 失敗 |
| 備考 | 特記事項 |

## 4. 参照方式の詳細

### 4.1 `@notation`（@ 記法）

**概要**: Claude Code が提供するファイル参照機能。ファイルパスの前に `@` を付けると、Claude Code がファイル内容を自動的にコンテキストに追加する。

**記法**:
```markdown
@AGENTS.md
@docs/aidlc/prompts/AGENTS.md
```

**処理フロー**:
1. ユーザーがプロンプトに `@path` を記述
2. Claude Code（クライアント）がパスを解決
3. ファイル内容をコンテキストに追加
4. AI にコンテキストと共にプロンプトを送信

**特徴**:
- 処理主体: **クライアント**（Claude Code）
- 対応環境: **Claude Code のみ**
- ネスト対応: 参照先ファイル内の `@` は **解釈されない**（1段階のみ）
- 利点: 確実にコンテキストに含まれる
- 欠点: Claude Code 以外の環境では動作しない

### 4.2 `instruction-based`（指示形式）

**概要**: プロンプト内にファイル読み込み指示を記述し、AI が Read ツールを使用してファイルを読み込む方式。

**記法**:
```markdown
`docs/aidlc/prompts/common/intro.md` を読み込んでください。
```

**処理フロー**:
1. AI がプロンプト内の指示を解釈
2. AI が Read ツールを呼び出してファイルを読み込む
3. AI が読み込んだ内容を理解・処理

**特徴**:
- 処理主体: **AI**
- 対応環境: **Claude Code / KiroCLI / その他**（Read ツールが使える環境すべて）
- ネスト対応: 参照先ファイル内の指示も AI が解釈可能（**多段階対応可能**）
- 利点: 環境非依存、ネスト参照可能
- 欠点: AI の判断に依存、確実性はやや低い

## 5. 検証マトリクス

### 5.1 PoC 検証対象（instruction-based のみ）

| # | 深度 | 環境 | 必須/任意 | 期待結果 |
|---|------|------|----------|----------|
| 1 | 1 | Claude Code | 必須 | 成功 |
| 2 | 2 | Claude Code | 必須（**合格ライン**） | 成功 |
| 3 | 3 | Claude Code | 任意（追加検証） | 成功 |
| 4 | 1 | KiroCLI | 任意（ユーザー確認） | 成功 |
| 5 | 2 | KiroCLI | 任意（ユーザー確認） | 成功 |

### 5.2 参考情報（@notation - 検証対象外）

| # | 深度 | 環境 | 期待動作 |
|---|------|------|----------|
| - | 1 | Claude Code | 成功（クライアント処理） |
| - | 2 | Claude Code | 失敗（ネスト不可） |
| - | 任意 | KiroCLI | 失敗（非対応） |

## 5.3 PoC 合格基準

**必須条件**: Claude Code で instruction-based 方式の **2段階参照（レベル1→2）が成功** すること

**追加条件（任意）**:
- 3段階参照（レベル1→2→3）の成功
- KiroCLI での動作確認（ユーザーによる確認）

## 6. 質疑応答

[Question] ネストした参照（参照深度）も検証対象に含めますか？
[Answer] はい、含める。ファイルA→B→Cのようなチェーン参照も検証する。

[Question] PoC成功の合格ラインとなる参照深度はどこまでですか？
[Answer] **2段階成功で合格**。レベル1→2が成功すればPoC合格とする。3段階は追加検証。

[Question] @notationの検証をUnit 001に含めますか？
[Answer] **含めない**。instruction-basedのみ検証対象とする。@notationはClaude Code限定のため参考情報として記載のみ。

[Question] KiroCLI検証の扱いはどうしますか？
[Answer] **ユーザー確認で代替**。KiroCLI環境があればユーザーが確認、なければスキップ可とする。

## 7. 設計判断

### 採用方針

Unit 002, 003 でのモジュール化では **`instruction-based`（指示形式）** を採用する。

**理由**:
1. KiroCLI を含む複数環境での動作が必要
2. ネスト参照のサポートが必要
3. `@notation` は Claude Code 限定であり、汎用性に欠ける

### リスクと対策

| リスク | 影響 | 対策 |
|--------|------|------|
| AI が指示を見逃す | 参照漏れ | 明確な指示形式を定義、Unit 004 でチェック機構導入 |
| ネスト深度の制限 | 複雑な構造が不可 | 実用的な深度（2-3段階）で設計 |

## 8. 次のステップ

- 論理設計で具体的な検証手順を定義
- 検証用ファイルの構造を設計
