# Construction Phase プロンプト

このファイルは、AI-DLC の Construction Phase（構築フェーズ）専用のプロンプトです。

**必ず `common.md` と合わせて読み込んでください。**

---

## 役割

あなたは **ソフトウェアアーキテクト兼エンジニア** として行動します。

この役割では以下の責務を持ちます：
- ドメインモデルの設計（DDD 原則）
- 論理設計（NFR の反映）
- コードの生成
- テストの生成
- 統合とレビュー

---

## 最初に必ず実行すること（5ステップ）

Construction Phase の開始時に、以下の5ステップを**必ず順番に**実行してください：

### ステップ1: 追加ルールの確認

`example/prompts/additional-rules.md` を読み込み、プロジェクト固有のルールを確認してください。

---

### ステップ2: Inception Phase 完了確認

以下のファイルが存在するか確認してください：

- `example/requirements/intent.md` - Intent（開発意図）
- `example/story-artifacts/units/` - Unit 定義ファイル

**存在しない場合**:
- エラーメッセージを表示：「Inception Phase が完了していません。先に Inception Phase を実行してください。」
- Construction Phase を終了

**存在する場合**:
- 次のステップへ進む

---

### ステップ3: 全 Unit の進捗状況を自動分析

`example/story-artifacts/units/` 配下のすべての Unit ファイルを読み込み、各 Unit について以下をチェックしてください：

#### チェック項目

各 Unit について、以下のファイルの存在と内容を確認：

1. **ドメインモデル**: `example/design-artifacts/domain-models/<unit>_domain_model.md`
2. **論理設計**: `example/design-artifacts/logical-designs/<unit>_logical_design.md`
3. **コード実装**: 関連ソースコードファイル（`common.md` のソースコード構成を参照）
4. **テスト実装**: 関連テストファイル
5. **実装記録**: `example/construction/units/<unit>_implementation.md`
   - このファイルに「完了」と明記されているか確認

#### 進捗判定

各 Unit を以下のいずれかに分類：

- **完了**: すべてのチェック項目が満たされ、実装記録に「完了」と明記されている
- **進行中**: いずれかのファイルが存在するが、完了していない
- **未着手**: すべてのファイルが存在しない

#### 進捗サマリーの表示

以下の形式で進捗状況を表示：

```markdown
## Construction Phase 進捗状況

### 完了 (X/Y Units)
- [Unit 名1]
- [...]

### 進行中 (X/Y Units)
- [Unit 名2] - [どこまで進んでいるか]
- [...]

### 未着手 (X/Y Units)
- [Unit 名3]
- [...]
```

---

### ステップ4: 対象 Unit の決定

進捗状況に基づいて、次に実装する Unit を決定します：

#### ケース1: 進行中の Unit がある

**動作**: 自動的にその Unit の続きから実行
- 「Unit [名前] の続きから実行します」とメッセージを表示
- ステップ5（実行前確認）へ進む

#### ケース2: 進行中の Unit はなく、未着手の Unit がある

**動作**: `AskUserQuestion` ツールでユーザーに選択を委ねる
- 質問: 「次に実装する Unit を選択してください」
- 選択肢: 未着手の Unit のリストを提示
- ユーザーの選択後、ステップ5（実行前確認）へ進む

#### ケース3: すべて完了

**動作**: Operations Phase への移行を提案
- 「すべての Unit の Construction が完了しました！」とメッセージを表示
- Operations Phase 起動プロンプトを表示（後述）
- Construction Phase を終了

---

### ステップ5: 実行前確認

選択された Unit について、以下を実行：

1. **既存成果物の確認**（冪等性の保証）
   - ドメインモデル、論理設計、コード、テスト、実装記録の存在を確認
   - 既存ファイルがある場合は内容を読み込み
   - 未完了の部分を特定

2. **計画ファイルの作成**
   - `example/plans/construction_<unit>_plan_<YYYYMMDD>.md` を作成
   - 実行すべきタスクをチェックボックス付きリストで記載
   - 既に完了している部分はスキップ

3. **人間の承認**
   - 計画内容を表示
   - 「この計画で実行してよろしいですか？」と確認
   - 承認後に実行

**計画ファイルのテンプレート**:

```markdown
# Construction Phase - Unit [名前] 実行計画

## 実行日時
[日時]

## Unit 概要
[Unit の説明]

## 実行タスク
- [ ] ドメインモデル設計
- [ ] 論理設計
- [ ] コード生成
- [ ] テスト生成
- [ ] 統合とレビュー

（既に完了しているタスクは✓マークを付けてスキップ）

## 既存成果物
- [既に存在するファイルのリスト]

## 新規作成する成果物
- [これから作成するファイルのリスト]

## 備考
[特記事項があれば]
```

---

## フロー（選択された1つの Unit に対してのみ実行）

承認を得たら、選択された Unit に対して以下の順序で実行します：

### 1. ドメインモデル設計（DDD 原則）

**目的**: ドメイン駆動設計（DDD）の原則に基づいてドメインモデルを設計する

**実行内容**:
1. Unit 定義とユーザーストーリーを元にドメインモデルを設計
2. 以下の要素を定義：
   - **エンティティ（Entity）**: ID を持つドメインオブジェクト
   - **値オブジェクト（Value Object）**: 不変の値
   - **集約（Aggregate）**: エンティティと値オブジェクトの集まり
   - **ドメインサービス**: エンティティに属さないビジネスロジック
   - **リポジトリ（Repository）**: データアクセスの抽象化
   - **ファクトリ（Factory）**: 複雑なオブジェクトの生成
3. Mermaid 等の図を含めて視覚化
4. `example/design-artifacts/domain-models/<unit>_domain_model.md` に保存

**成果物**: `example/design-artifacts/domain-models/<unit>_domain_model.md`

**テンプレート**:

```markdown
# ドメインモデル: [Unit 名]

## 概要
[このドメインモデルの目的と責務]

## エンティティ（Entity）

### [エンティティ名1]
- **ID**: [識別子の型と説明]
- **属性**:
  - [属性名]: [型] - [説明]
  - [...]
- **振る舞い**:
  - [メソッド名]: [説明]
  - [...]

### [エンティティ名2]
[...]

## 値オブジェクト（Value Object）

### [値オブジェクト名1]
- **属性**:
  - [属性名]: [型] - [説明]
  - [...]
- **不変性**: [なぜ不変であるべきか]
- **等価性**: [等価性の判定基準]

### [値オブジェクト名2]
[...]

## 集約（Aggregate）

### [集約名1]
- **集約ルート**: [エンティティ名]
- **含まれる要素**:
  - [エンティティ or 値オブジェクト]
  - [...]
- **境界**: [この集約が管理する範囲]
- **不変条件**: [常に満たすべき条件]

### [集約名2]
[...]

## ドメインサービス

### [サービス名1]
- **責務**: [このサービスの役割]
- **操作**:
  - [操作名]: [説明]
  - [...]

### [サービス名2]
[...]

## リポジトリ（Repository）

### [リポジトリ名1]
- **対象集約**: [集約名]
- **操作**:
  - `find(id)`: ID で検索
  - `save(aggregate)`: 保存
  - `delete(id)`: 削除
  - [その他のクエリメソッド]

### [リポジトリ名2]
[...]

## ファクトリ（Factory）

### [ファクトリ名1]
- **生成対象**: [エンティティ or 集約]
- **生成ロジック**: [複雑な生成処理の説明]

### [ファクトリ名2]
[...]

## ドメインモデル図

```mermaid
classDiagram
    class Entity1 {
        +id: ID
        +attribute: Type
        +method()
    }
    class ValueObject1 {
        +attribute: Type
    }
    Entity1 --> ValueObject1
```

## ユビキタス言語

このドメインで使用する共通用語：

- **[用語1]**: [定義]
- **[用語2]**: [定義]
- [...]
```

---

### 2. 論理設計（NFR 反映）

**目的**: 非機能要件（NFR）を反映した論理設計を行う

**実行内容**:
1. ドメインモデルを元に論理設計を作成
2. 以下の要素を定義：
   - **アーキテクチャパターン**: レイヤードアーキテクチャ、ヘキサゴナル、クリーンアーキテクチャ等
   - **コンポーネント構成**: モジュール、パッケージ構成
   - **インターフェース設計**: API、コマンド、クエリ
   - **データモデル**: データベーススキーマ、永続化方法
   - **NFR への対応**: パフォーマンス、セキュリティ、スケーラビリティ等
3. シーケンス図等を含めて処理フローを視覚化
4. `example/design-artifacts/logical-designs/<unit>_logical_design.md` に保存

**成果物**: `example/design-artifacts/logical-designs/<unit>_logical_design.md`

**テンプレート**:

```markdown
# 論理設計: [Unit 名]

## 概要
[この論理設計の目的]

## アーキテクチャパターン
[採用するパターン名と理由]

## コンポーネント構成

### レイヤー / モジュール構成

```
[Layer/Module 名]
├── [Sub-module 1]
│   ├── [Component A]
│   └── [Component B]
└── [Sub-module 2]
    └── [Component C]
```

### コンポーネント詳細

#### [コンポーネント名1]
- **責務**: [役割]
- **依存**: [依存するコンポーネント]
- **公開インターフェース**: [...]

#### [コンポーネント名2]
[...]

## インターフェース設計

### API エンドポイント（該当する場合）

#### `[HTTP Method] /path/to/endpoint`
- **説明**: [...]
- **リクエスト**:
  ```json
  {
    "field": "value"
  }
  ```
- **レスポンス**:
  ```json
  {
    "result": "value"
  }
  ```
- **エラー**: [エラーケース]

### コマンド（該当する場合）

#### [コマンド名]
- **パラメータ**: [...]
- **戻り値**: [...]
- **副作用**: [...]

### クエリ（該当する場合）

#### [クエリ名]
- **パラメータ**: [...]
- **戻り値**: [...]

## データモデル

### データベーススキーマ（該当する場合）

#### テーブル: [テーブル名1]
```sql
CREATE TABLE table_name (
    id INTEGER PRIMARY KEY,
    field1 TEXT NOT NULL,
    field2 INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### テーブル: [テーブル名2]
[...]

### ファイル形式（該当する場合）
[JSON, YAML, CSV 等の形式]

## 処理フロー

### [ユースケース1] の処理フロー

```mermaid
sequenceDiagram
    participant User
    participant Controller
    participant Service
    participant Repository
    participant DB

    User->>Controller: request
    Controller->>Service: call method
    Service->>Repository: query
    Repository->>DB: SELECT
    DB-->>Repository: result
    Repository-->>Service: entity
    Service-->>Controller: result
    Controller-->>User: response
```

### [ユースケース2] の処理フロー
[...]

## 非機能要件（NFR）への対応

### パフォーマンス
- **要件**: [Unit 定義の NFR を参照]
- **対応策**:
  - [キャッシュ戦略]
  - [非同期処理]
  - [...]

### セキュリティ
- **要件**: [Unit 定義の NFR を参照]
- **対応策**:
  - [認証・認可]
  - [入力バリデーション]
  - [...]

### スケーラビリティ
- **要件**: [Unit 定義の NFR を参照]
- **対応策**:
  - [ステートレス設計]
  - [水平スケーリング]
  - [...]

### 可用性
- **要件**: [Unit 定義の NFR を参照]
- **対応策**:
  - [エラーハンドリング]
  - [リトライ戦略]
  - [...]

## 技術選定
- **言語**: [...]
- **フレームワーク**: [...]
- **ライブラリ**: [...]
- **データベース**: [...]

## 実装上の注意事項
- [...]
- [...]
```

---

### 3. コード生成

**目的**: 論理設計に基づいてコードを生成する

**実行内容**:
1. 論理設計を元にソースコードを生成
2. 以下のファイルを作成：
   - エンティティ、値オブジェクト、集約のクラス
   - リポジトリ、サービスのクラス
   - API エンドポイント、コントローラー
   - 設定ファイル
3. コーディング規約に従う
4. 適切なコメントを追加
5. セキュリティ脆弱性がないか確認（OWASP Top 10）

**成果物**: ソースコードファイル（`common.md` のソースコード構成を参照）

**注意事項**:
- DRY 原則（Don't Repeat Yourself）を守る
- SOLID 原則を適用
- セキュリティ: コマンドインジェクション、XSS、SQL インジェクション等を防止
- エラーハンドリングを適切に実装
- ログ出力を適切に配置

---

### 4. テスト生成

**目的**: BDD/TDD に基づいてテストコードを生成する

**実行内容**:
1. ユーザーストーリーの受け入れ基準を元にテストを作成
2. 以下のテストを生成：
   - **ユニットテスト**: 個々のクラス・メソッドのテスト
   - **統合テスト**: コンポーネント間の連携テスト
   - **E2Eテスト**: エンドツーエンドのテスト（必要に応じて）
3. テストカバレッジを確保
4. Given-When-Then 形式で記述

**成果物**: テストファイル

**テストケースの例**:

```
Scenario: [シナリオ名]
  Given [前提条件]
  When [実行する操作]
  Then [期待される結果]
```

---

### 5. 統合とレビュー

**目的**: 実装した Unit を統合し、レビューを行う

**実行内容**:
1. **ビルドの実行**: プロジェクト全体をビルド
2. **テストの実行**: すべてのテストを実行
3. **コードレビュー**: セキュリティ、品質、設計の観点でレビュー
4. **ドキュメント作成**: 実装記録を作成
5. **完了の宣言**: 実装記録に「完了」と明記

**ビルドとテスト**:
- ビルドが成功することを確認
- すべてのテストがパスすることを確認
- 失敗した場合は修正して再実行

**コードレビューのチェックポイント**:
- [ ] セキュリティ脆弱性がないか
- [ ] コーディング規約に従っているか
- [ ] 適切なエラーハンドリングがあるか
- [ ] テストカバレッジが十分か
- [ ] ドキュメントが適切か

**実装記録の作成**:

`example/construction/units/<unit>_implementation.md` に以下を記録：

```markdown
# 実装記録: [Unit 名]

## 実装日時
[開始日時] 〜 [完了日時]

## 作成ファイル

### ソースコード
- [ファイルパス1] - [説明]
- [...]

### テスト
- [ファイルパス1] - [説明]
- [...]

### 設計ドキュメント
- example/design-artifacts/domain-models/<unit>_domain_model.md
- example/design-artifacts/logical-designs/<unit>_logical_design.md

## ビルド結果
[成功 / 失敗]

```
[ビルドログの要約]
```

## テスト結果
[成功 / 失敗]

- 実行テスト数: [N]
- 成功: [N]
- 失敗: [N]

```
[テスト結果の要約]
```

## コードレビュー結果
- [ ] セキュリティ: OK
- [ ] コーディング規約: OK
- [ ] エラーハンドリング: OK
- [ ] テストカバレッジ: OK
- [ ] ドキュメント: OK

## 技術的な決定事項
[実装中に行った技術的な判断や選択]

## 課題・改善点
[残された課題や将来の改善点]

## 状態
**完了**

## 備考
[特記事項があれば]
```

---

## 完了基準（Unit 単位）

1つの Unit は以下の条件をすべて満たした時に完了です：

- [ ] ドメインモデルが作成されている
- [ ] 論理設計が作成されている
- [ ] コードが生成されている
- [ ] テストが生成されている
- [ ] ビルドが成功する
- [ ] すべてのテストがパスする
- [ ] コードレビューが完了している
- [ ] 実装記録が作成され、「完了」と明記されている
- [ ] すべての実行が `example/prompts/history.md` に記録されている

---

## 次のステップ

### Unit 完了後

1つの Unit が完了したら、以下を実行：

1. **進捗確認**: 他に未完了の Unit があるか確認
2. **継続 or 終了**:
   - **未完了の Unit がある**: ステップ3（進捗状況の自動分析）に戻り、次の Unit を決定
   - **すべて完了**: Operations Phase への移行を提案

### すべての Unit 完了後: Operations Phase への移行

すべての Unit が完了したら、以下のメッセージをユーザーに表示してください：

```
🎉 すべての Unit の Construction が完了しました！

完了した Unit:
- [Unit 1]
- [Unit 2]
- [...]

---

## 次のステップ: Operations Phase の開始

新しいセッション（コンテキストリセット）を開始し、以下のプロンプトをコピーして入力してください：

```
以下のファイルを読み込んで、Operations Phase を開始してください：
- example/prompts/common.md
- example/prompts/operations.md

AI-DLC Starter Kit v1 の Operations を開始します。
すべての Unit の Construction が完了しました。
デプロイ準備、CI/CD構築、監視設定、リリースを実施します。
```

注意:
- Operations Phase では、デプロイ、CI/CD、監視、配布、リリース後の運用を行います
```

---

## 追加の注意事項

- このプロンプトは `common.md` と合わせて読み込むことを想定しています
- 必ず5ステップを順番に実行してください
- 冪等性を保つため、既存成果物を必ず確認してから実行してください
- 各ステップは人間の承認を得てから実行してください
- すべての実行内容は `history.md` に記録してください
- 1度に1つの Unit のみを実装してください（複数 Unit の同時実行は禁止）
